#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/atomic.h>
#include <linux/uaccess.h>
#include <linux/version.h>
#include <linux/minmax.h>
#include <linux/delay.h>
#include <linux/device.h>

static int major;
#define DEVICE_NAME	"chardev1"
static ssize_t chardev_read(struct file*,char* __user,size_t,loff_t* );
static ssize_t chardev_write(struct file*,const char* __user,size_t,loff_t* );
static int chardev_open(struct inode*,struct file*);
static int chardev_release(struct inode*,struct file*);

static struct device* chardev;
static struct class *cls;


//function definitons
static int len_dev_buffer=0;
#define BUF_MAX_LEN	1024
static char chardev_buf[BUF_MAX_LEN];


static ssize_t chardev_read(struct file* file,char* __user buffer,size_t length,loff_t* offset )
{
	if(*offset >= len_dev_buffer) 
	{
		pr_debug("offset non zero");
		*offset=0;
		return 0;
	}
	int len=min(len_dev_buffer- *offset,(int) length);
	if(copy_to_user(buffer,chardev_buf+*offset,len))
	{
		pr_err("error in copying contents to userspace");
		return -EFAULT;
	}
	pr_info("copied to user space successfully:%s",buffer);
	*offset+=len;
	return len;
}

static ssize_t chardev_write(struct file* file,const char* __user buffer,size_t length,loff_t* offset)
{
	int len=min(BUF_MAX_LEN,(int)length);
	if(copy_from_user(chardev_buf,buffer,len))
	{
		
		pr_err("error in copying contents to kernel");
		return -EFAULT;
	}
	chardev_buf[len]='\0';
	pr_info("copied the message from user space to file %s.",chardev_buf);
	*offset+=len;
	return len;

}
enum
{
	N_USED,
	USED
};
static atomic_t aldready_open=ATOMIC_INIT(0);

static int chardev_open(struct inode*inode ,struct file*file)
{
	if(atomic_cmpxchg(&aldready_open,N_USED,USED))
	{
		pr_alert("device file aldready open");
		return -EBUSY;
	}
	pr_info("opened chardev file");
	return 0;
}
static int chardev_release(struct inode*inode,struct file*file)
{
	atomic_set(&aldready_open,N_USED);
	pr_info("file released successfullly");
	return 0;
}




//function definition ends
static struct file_operations f_ops=
{
	read:chardev_read,
	write:chardev_write,
	open:chardev_open,
	release:chardev_release
};
static int __init chardev_init(void)
{
	//get a major number
	major=register_chrdev(0,DEVICE_NAME,&f_ops);
	//check if failed or not
	if(major<0)
	{
		pr_alert("failed to get major number");
		return major;
	}
	pr_info("chardev file created with a major number %d",major);
	//create class for passing as parameter in device_create
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
	cls=class_create(DEVICE_NAME);
#else
	cls=class_create(THIS_MODULE,DEVICE_NAME);
#endif
	//create a character device and assign its value to type struct device*
	chardev=device_create(cls,NULL,MKDEV(major,0),NULL,DEVICE_NAME);
	//check if failed or not
	if(!chardev)
	{
		pr_err("unsuccessfull in creating a chardevice");
		return -ENODEV;
	}
	pr_info("%s created successfully",DEVICE_NAME);
	return 0;
}
static void __exit chardev_exit(void)
{
	//destory device first because we need major number and class pointer
	device_destroy(cls,MKDEV(major,0));
	//destroy class 
	class_destroy(cls);
	//unregister the major number
	unregister_chrdev(major,DEVICE_NAME);
}
module_init(chardev_init);
module_exit(chardev_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Anto");

